from matplotlib import pyplot as plt

# Types of Power Pattern generated by Wind Turbine during a one day
P_wind1 = [ 0.81, 1.00, 0.57, 0.38, 0.22, 0.35, 0.44, 0.36, 0.57, 0.82, 0.58, 0.33, 0.35, 0.64, 0.64, 0.22, 0.18, 0.10, 0.05, 0.08, 0.15, 0.08, 0.14, 0.13 ]
P_wind2 = [ 0.81, 1.00, 0.57, 0.38, 0.22, 0.35, 0.44, 0.36, 0.57, 0.82, 0.58, 0.33, 0.35, 0.64, 0.64, 0.22, 0.18, 0.10, 0.05, 0.08, 0.15, 0.08, 0.14, 0.13 ]
P_wind3 = [ 0.81, 1.00, 0.57, 0.38, 0.22, 0.35, 0.44, 0.36, 0.57, 0.82, 0.58, 0.33, 0.35, 0.64, 0.64, 0.22, 0.18, 0.10, 0.05, 0.08, 0.15, 0.08, 0.14, 0.13 ]
P_wind4 = [ 0.81, 1.00, 0.57, 0.38, 0.22, 0.35, 0.44, 0.36, 0.57, 0.82, 0.58, 0.33, 0.35, 0.64, 0.64, 0.22, 0.18, 0.10, 0.05, 0.08, 0.15, 0.08, 0.14, 0.13 ]

# Types of Power Pattern generated by Photovotaic during a one day
P_pv1 = [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.5, 0.7, 0.9, 1.0, 0.9, 0.8, 0.7, 0.53125, 0.2, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
P_pv2 = [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.5, 0.7, 0.9, 1.0, 0.9, 0.8, 0.7, 0.53125, 0.20, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]
P_pv3 = [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.5, 0.7, 0.9, 1.0, 0.9, 0.8, 0.7, 0.53125, 0.2, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]
P_pv4 = [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.5, 0.7, 0.9, 1.0, 0.9, 0.8, 0.7, 0.53125, 0.2, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]

# Types of Load Pattern during a one day
P_load1 = [ 0.33, 0.32, 0.32, 0.31, 0.30, 0.30, 0.34, 0.40, 0.50, 0.70, 0.69, 0.60, 0.55, 0.70, 0.68, 0.60, 0.53, 0.5, 0.47, 0.45, 0.4, 0.36, 0.34, 0.33 ]
P_load2 = [ 0.33, 0.32, 0.32, 0.31, 0.30, 0.30, 0.34, 0.40, 0.50, 0.70, 0.69, 0.60, 0.55, 0.70, 0.68, 0.60, 0.53, 0.50, 0.47, 0.45, 0.40, 0.36, 0.34, 0.33 ]
P_load3 = [ 0.33, 0.32, 0.32, 0.31, 0.30, 0.30, 0.34, 0.40, 0.50, 0.70, 0.69, 0.60, 0.55, 0.70, 0.68, 0.60, 0.53, 0.50, 0.47, 0.45, 0.4, 0.36, 0.34, 0.33 ]
P_load4 = [ 0.33, 0.32, 0.32, 0.31, 0.30, 0.30, 0.34, 0.40, 0.50, 0.70, 0.69, 0.60, 0.55, 0.70, 0.68, 0.60, 0.53, 0.50, 0.47, 0.45, 0.40, 0.36, 0.34, 0.33 ]

# input a efficiency of inverter, constraints of LOLP, constraints ofdummy
print('Enter the efficiency of inverter: ')
Ef_inv = input()
print('Enter the constraints of LOLP(0<Con_LOLP<0.1: ')
Con_LOLP = input()
print('Enter the constraints of dummy(0<Con_dummy<0.05: ')
Con_dummy = input()



# Choice a pattern of wind turbine, Photovoltaic and Load
print('choice a Types of wind turbine(P_wind(1~4)): ')
prompt1 = int(input())
if prompt1 == 1:
    P_wind = [round(5 * value, 3) for idx, value in enumerate(P_wind1)]
elif prompt1 == 2:
    P_wind = [round(7 * value, 3) for idx, value in enumerate(P_wind2)]
elif prompt1 == 3:
    P_wind = [round(10 * value, 3) for idx, value in enumerate(P_wind3)]
else:
    P_wind = [round(20 * value, 3) for idx, value in enumerate(P_wind4)]



print('choice a Types of Photovoltaic(P_pv(1~4)): ')
prompt2 = int(input())
if prompt2 == 1:
    P_pv = [round(5 * value, 3) for idx, value in enumerate(P_pv1)]
elif prompt2 == 2:
    P_pv = [round(7 * value, 3) for idx, value in enumerate(P_pv2)]
elif prompt2 == 3:
    P_pv = [round(10 * value, 3) for idx, value in enumerate(P_pv3)]
else:
    P_pv = [round(20 * value, 3) for idx, value in enumerate(P_pv4)]



print('choice a Types of Load Pattern(P_load(1~4)): ')
prompt3 = int(input())
if prompt3 == 1:
    P_load = [round(5 * value, 3) for idx, value in enumerate(P_load1)]
elif prompt3 == 2:
    P_load = [round(10 * value, 3) for idx, value in enumerate(P_load2)]
elif prompt3 == 3:
    P_load = [round(15 * value, 3) for idx, value in enumerate(P_load3)]
else:
    P_load = [round(20 * value, 3) for idx, value in enumerate(P_pv4)]


# Enter battery data, initial SOC( %), SOC_min( %), SOC_max( %), P_bc(kW), P_bd(kW), C_bat = 20; % Capacity(kWh)
# Enter efficiency of inverter
Ef_inv = 0.95
# Enter constraints of LOLP and dummy loads
Con_LOLP = 0.05
Con_dummy = 0.04

# Enter battery data, initial SOC(%), SOC_min(%), SOC_max(%), P_bc(kW), P_bd(kW)
C_bat = 20				# Capacity(kWh)
SOC_ini = 30			# initial SOC of battery
SOC_min = 10			# minimum SOC of battery
SOC_max = 90			# maximum SOC of battery
P_bc = [0] * 24		    # output of battery in charge mode
P_bd = [0] * 24		    # output of battery in discharge mode
Ef_bc = 0.9			    # efficiency of battery in charge mode
Ef_bd = 0.85			# efficiency of battery in discharge mode
r_sd = 0.002			# self - discharge rate of battery

# Enter dummy load capacity(kW)
P_dummy = [0] * 24
E_dummy = 0

# Enter diesel generator capacity(kW), output(kW) and efficiency
P_dgr = 10
P_dg = [0] * 24
Ef_dg = 0.95

# NPSP algorithm
t = 1							# initial time
LOLP = [0] * 24					# initial LOLP at each time
LOLP_sum = 0
E_bat = (C_bat * SOC_ini) / 100	# initial kWh capacity of battery at each time
SOC = [0] * 24					# initial SOC of battery at each time

# iteration for day calculation(24h)
for t in range(24):

    SOC[t] = E_bat / C_bat * 100     # SOC calculation of battery at each time

    if P_wind[t] > P_load[t]: # occurred surplus energy in HRES system
        if SOC[t] < SOC_max: # check SOC of battery whether the SOC has enough
            P_bc[t] = (P_wind[t] - P_load[t] * Ef_inv + P_pv[t]) * Ef_bc #calculate charge capacity of battery
            E_bat = E_bat * (1 - r_sd) + P_bc[t] * Ef_bc         # accumulate capacity of battery
        else:
            P_bc[t] = 0 # calculate charge capacity of battery
            P_dummy[t] = (P_wind[t] - P_load[t]) + P_pv[t] * Ef_inv # calculate capacity of dummy loads to cover surplus energy in HRES system
            E_dummy = E_dummy + P_dummy[t] # accumulate capacity of dummy loads to check total used capacity of dummy loads

    if P_wind[t] <= P_load[t] and (P_wind[t] + P_pv[t] * Ef_inv) > P_load[t]: # occurred surplus energy in HRES system
        if SOC[t] < SOC_max: # check SOC of battery whether the SOC has enough
            P_bc[t] = (P_wind[t] + P_pv[t] * Ef_inv - P_load[t]) * Ef_bc * Ef_inv # calculate charge capacity of battery
            E_bat = E_bat * (1 - r_sd) + P_bc[t] * Ef_bc # accumulate capacity of battery
        else:
            P_bc[t] = 0  # calculate charge capacity of battery
            P_dummy[t] = P_wind[t] + P_pv[t] * Ef_inv - P_load[t]  # calculate capacity of dummy loads to cover surplus energy in HRES system
            E_dummy = E_dummy + P_dummy[t]  # accumulate capacity of dummy loads to check total used capacity of dummy loads

    if P_wind[t] <= P_load[t] and (P_wind[t] + P_pv[t] * Ef_inv) <= P_load[t]: # occurred deficit energy in HRES system
        if SOC[t] > SOC_min: # check SOC of battery whether the SOC has lack of capacity
            P_bd[t] = (P_pv[t] - (P_load[t] - P_wind[t]) / Ef_inv) * Ef_bd # calculate discharge capacity of battery
            E_bat = E_bat * (1 - r_sd) - abs(P_bd[t]) * Ef_bd # accumulate capacity of battery
        else:
            P_bd[t] = 0 # calculate charge capacity of battery
            P_dg[t] = (P_load[t] - P_wind[t] - P_pv[t] * Ef_inv) / Ef_dg # calculate capacity of diesel generator to cover deficit energy in HRES system
            if P_dg[t] > P_dgr: # check the capacity of diesel generator whether it exceeds rated capacity of diesel generator
                LOLP[t] = 1 # evaluate LOLP at time t
                LOLP_sum = LOLP_sum + LOLP[t] # accumulate LOLP at each time
            else:
                LOLP[t] = 0 # evaluate LOLP at time t

# check capacity of HRES with constraints of LOLP and dummy loads
if E_dummy <= 0:
    print('Need to increasing capacity of PV or WT.\n')
else:
    if E_dummy > max(P_load):
        print('Need to decreasing capacity of PV or WT.\n')
    else:
        if LOLP_sum / t > Con_LOLP:
            print('Need to increasing capacity of PV or WT.\n')
        else:
            print('Present capacities of PV and WT are optimal.\n')


# ploting the simulation results

# P_wind 그래프
plt.subplot(3, 2, 1)
x_pos = [x for x in range(24)]
y_pos1 = [round(P_wind[idx], 3) for idx, y in enumerate(P_wind)]
plt.plot(x_pos, y_pos1)
plt.xlabel('t(h)')
plt.ylabel('Power of Wind Turbine(kWh)')

# P_dummy 그래프
plt.subplot(3, 2, 2)
y_pos2 = [round(P_dummy[idx], 3) for idx, y in enumerate(P_dummy)]
plt.plot(x_pos, y_pos2)
plt.xlabel('t(h)')
plt.ylabel('Power of Dummy(kWh)')

# P_pv 그래프
plt.subplot(3, 2, 3)
y_pos3 = [round(P_pv[idx], 3) for idx, y in enumerate(P_pv)]
plt.plot(x_pos, y_pos3)
plt.xlabel('t(h)')
plt.ylabel('Power of Photovoltaic(kWh)')

# Pbat 그래프
plt.subplot(3, 2, 4)
y_pos4 = [round(bc + bd, 3) for bc, bd in zip(P_bc, P_bd)]
plt.plot(x_pos, y_pos4)
plt.xlabel('t(h)')
plt.ylabel('Power of Battery(kWh)')

# P_load 그래프
plt.subplot(3, 2, 5)
y_pos5 = [round(P_load[idx], 3) for idx, y in enumerate(P_load)]
plt.plot(x_pos, y_pos5)
plt.xlabel('t(h)')
plt.ylabel('Power of Load(kWh)')

# SOC 그래프
plt.subplot(3, 2, 6)
y_pos6 = [round(SOC[idx], 3) for idx, y in enumerate(SOC)]
plt.plot(x_pos, y_pos6)
plt.xlabel('t(h)')
plt.ylabel('SOC(%)')

plt.show()